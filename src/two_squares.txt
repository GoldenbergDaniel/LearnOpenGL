// https://learnopengl.com/Getting-started/Hello-Triangle

#include <stdio.h>
#include <GLFW/glfw3.h>
#include "../lib/glad/glad.h"

#include "common.hpp"
#include "shaders.hpp"

void handle_input(GLFWwindow *window);
void verify_shader_status(u32 shader, u32 status);

i32 main()
{
  glfwInit();

  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, true);
  glfwWindowHint(GLFW_RESIZABLE, false);

  GLFWwindow *window = glfwCreateWindow(800, 450, "OPENGL", nullptr, nullptr);
  glfwMakeContextCurrent(window);
  
  gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);

  // Vertex shader handles the attributes of the vertices
  u32 v_shader = glCreateShader(GL_VERTEX_SHADER);
  glShaderSource(v_shader, 1, &v_shader_source, nullptr);
  glCompileShader(v_shader);
  verify_shader_status(v_shader, GL_COMPILE_STATUS);

  // Fragment shader handles the attributes of the pixels between the vertices
  u32 f_shader = glCreateShader(GL_FRAGMENT_SHADER);
  glShaderSource(f_shader, 1, &f_shader_source, nullptr);
  glCompileShader(f_shader);
  verify_shader_status(f_shader, GL_COMPILE_STATUS);

  // Link shaders into shader program
  u32 shader_program = glCreateProgram();
  glAttachShader(shader_program, v_shader);
  glAttachShader(shader_program, f_shader);
  glLinkProgram(shader_program);
  verify_shader_status(shader_program, GL_LINK_STATUS);

  glDeleteShader(v_shader);
  glDeleteShader(f_shader);

  // RECTANGLE 1

  // The vertices of a rectange in 3D space
  f32 vertices1[12] = {
    0.75f,  0.75f, 0.0f,  // top right    
    0.75f, 0.0f, 0.0f,  // bottom right
    0.25f, 0.0f, 0.0f,  // bottom left
    0.25f,  0.75f, 0.0f   // top left 
  };

  // Vertex array object stores the state needed to supply vertex data
  u32 vao1;
  glGenVertexArrays(1, &vao1);
  glBindVertexArray(vao1);

  // Vertex buffer object stores vertex data that is uploaded to GPU
  u32 vbo1;
  glGenBuffers(1, &vbo1);
  glBindBuffer(GL_ARRAY_BUFFER, vbo1);
  glBufferData(GL_ARRAY_BUFFER, sizeof (vertices1), vertices1, GL_DYNAMIC_DRAW);

  // Tells OpenGL how it should interpret the vertex data
  glVertexAttribPointer(0, 3, GL_FLOAT, false, sizeof (f32) * 3, (void *) 0);
  glEnableVertexAttribArray(0);
  glBindVertexArray(0);

  // RECTANGLE 2

  // The vertices of a rectange in 3D space
  f32 vertices2[12] = {
    -0.75f,  -0.75f, 0.0f,  // top right    
    -0.75f, 0.0f, 0.0f,  // bottom right
    -0.25f, 0.0f, 0.0f,  // bottom left
    -0.25f,  -0.75f, 0.0f   // top left 
  };

  u32 vao2;
  glGenVertexArrays(1, &vao2);
  glBindVertexArray(vao2);

  u32 vbo2;
  glGenBuffers(1, &vbo2);
  glBindBuffer(GL_ARRAY_BUFFER, vbo2);
  glBufferData(GL_ARRAY_BUFFER, sizeof (vertices2), vertices2, GL_DYNAMIC_DRAW);

  // Tells OpenGL how it should interpret the vertex data
  glVertexAttribPointer(0, 3, GL_FLOAT, false, sizeof (f32) * 3, (void *) 0);
  glEnableVertexAttribArray(0);
  glBindVertexArray(0);

  // Element buffer objects stores indices of the verteces that should be drawn
  u8 indices[6] = {
    0, 1, 3, // first triangle
    1, 2, 3 // second triangle
  };

  u32 ebo;
  glGenBuffers(1, &ebo);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof (indices), indices, GL_STATIC_DRAW);

  glUseProgram(shader_program);

  while (!glfwWindowShouldClose(window))
  {
    // Handle events
    glfwPollEvents();
    handle_input(window);

    // Clear screen
    glClearColor(0.4f, 0.3f, 0.8f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw rectangle 1
    glBindVertexArray(vao1);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices1), vertices1, GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0);

    // Draw rectangle 2
    glBindVertexArray(vao2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices2), vertices2, GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0);

    // Swap the front and back buffers to make the rendered image visible
    glfwSwapBuffers(window);
  }

  glfwTerminate();

  return 0;
}

void handle_input(GLFWwindow *window)
{
  if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) 
  {
    glfwSetWindowShouldClose(window, true);
  }
  else if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
  { 
    printf("Space key pressed\n");
  }
}

void verify_shader_status(u32 shader, u32 status)
{
  i32 success;
  i8 status_log[512];

  glGetShaderiv(shader, status, &success);
  glGetShaderInfoLog(shader, 512, nullptr, status_log);

  if (!success)
  {
    printf("Shader error!\n");
    printf("%s", status_log);
  }
}
